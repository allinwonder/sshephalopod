{
  "name": "async-ext",
  "version": "0.1.5",
  "description": "Extensions to the Node.js async library",
  "main": "async-ext.js",
  "engines": {
    "node": ">=0.10.x"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Clever/async-ext.git"
  },
  "scripts": {
    "prepublish": "make",
    "test": "make test"
  },
  "license": "BSD",
  "dependencies": {
    "underscore": "~1.5.2"
  },
  "peerDependencies": {
    "async": ">=0.1.x"
  },
  "devDependencies": {
    "coffee-script": "~1.6.3",
    "sinon": "~1.7.3",
    "mocha": "~1.13.0",
    "async": "~0.1.x"
  },
  "readme": "# async-ext\n\nThis module consists of a set of functions to extend the capabilities of the Node.js [async](https://github.com/caolan/async) library.\n\n## Installation\n\n    npm install async\n    npm install async-ext\n\n## Usage\n\nThe easiest way to use async-ext is to extend the async object with the new functions. Here's how you might do it with Underscore:\n\n```coffeescript\n_ = require 'underscore'\nasync = _.extend require('async'), require('async-ext')\n```\n\n## Functions\n\n### async.lift(fun)\n\n\"Lifts\" a regular old synchronous function into the wondrous world of async.\n\nWhy would you ever want to make *more* functions async then you have to? Well, imagine you were using `async.waterfall` to get fetch some data asynchronously, transform it synchronously, and send it off somewhere else asynchronously. Your code might look like this:\n\n```coffeescript\nasync.waterfall [\n    fetchData\n    (data, cb) ->\n        try \n            data = transform data\n            sendData data, cb\n        catch err\n            setImmediate -> cb err\n], errHandler\n```\n\nWith `async.lift`, you can write that like this:\n\n```coffeescript\nasync.waterfall [\n    fetchData\n    async.lift (data) -> transform data\n    sendData\n], errHandler\n```\n\n`async.lift` takes a synchronous function and returns an asynchronous version of that function that applies its callback to any results returned by the original function.\n\nThe input function may accept any number of arguments - the resulting function will as well. If the input function returns a single value, the callback will be called with that value. If the input function returns an array, the callback will be applied to the array.\n\nAny errors thrown by the input function will be caught and passed to the callback. If no error is thrown, the callback will be called with `null` as the error argument.\n\nThe resulting function will call its callback using `setImmediate`, to prevent [releasing the Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n\n### async.tap(fun)\n\nLifts a synchronous function but ignores its return value, instead passing along whatever arguments it receives. This can be useful for inserting functions into pipelines when you only care about their side effects.\n\nFor example, we can insert some logging statements into our previous waterfall without having to modify any of the preexisting code:\n\n```coffeescript\nasync.waterfall [\n    fetchData\n    async.lift (data) -> transform data\n    async.tap (data) -> console.log 'got some data', data\n    sendData # is called with the same data as the logging function\n    async.tap -> console.log 'done sending!'\n], errHandler\n```\n\nAny errors thrown by the input function will be caught and passed to the callback. If no error is thrown, the callback will be called with `null` as the error argument.\n\n### async.once(fun)\n\nLike `_.once`, takes an asynchronous function and returns a version of the function that will only run once. Subsequent calls to the function will call the given callback with the same results that were passed to the callback of the first invocation.\n\nIf the function is called multiple times, the callbacks will be called in the order of the invocations.\n\n```coffeescript\ninit_db = async.once(db.connect)\ninit_db (err, conn1) ->\n    console.log 'inited 1'\n    init_db (err, conn2) ->\n        console.log 'inited 2'\n)\ninit_db (err, connr3) ->\n    console.log 'inited 3'\n# logs 1, 3, 2\n# conn1 is conn2 is conn3\n```\n\n### async.mapValues(obj, fun, cb)\n\nTakes an object, an async function, and a final callback. `async.mapValues` creates a new object whose values are the results of applying the function to each key/value pair of the original object. The resulting object is passed to the final callback.\n\nIf the function calls its callback with an error, it will short-circuit the computation and pass the error to the final callback.\n\n```coffeescript\nphoto_obj = { file1: 'some-file.txt', file2: 'another-file.txt' }\nasync.mapValues photo_obj, fs.readFile, (err, res) ->\n    console.log res # { file: <some-file data>, file2: <another-file data> }\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Clever/async-ext/issues"
  },
  "_id": "async-ext@0.1.5",
  "dist": {
    "shasum": "06db3432bd0975ec6a3a7ef85552fc8754287640"
  },
  "_from": "async-ext@~0.1.4",
  "_resolved": "https://registry.npmjs.org/async-ext/-/async-ext-0.1.5.tgz"
}
